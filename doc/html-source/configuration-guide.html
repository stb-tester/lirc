    <!-- configuration-guide +++++++++++++++++++++++++++++++++++++++++++++ -->

    <A NAME="configuration-guide"></A>
    <H1 ALIGN="CENTER">Configuration guide</H1>
    <HR WIDTH="70%">
    <h2 align="center">About this guide</h2>
    <p>
    This guide tries to describe the basic configuration steps for
    commonly used hardware.  It's focused on the basic usage scenario
    to get the remote up and running, the more advanced features are
    not covered. This includes irexec, lircmd, ir blasting and the
    TCP/IP-based remote features.
    </p>
    <A NAME="why-use-lirc"></A><HR>
    <h2 align="center">Why should I use LIRC?</h2>
    <p>
    Recent Linux kernels have built-in support for IR remotes. Using that,
    pressing an up-arrow on the remote works the same way as pressing the
    up-arrow on a keyboard. This is a modern "just works" solution. On
    the other hand, LIRC is an old style linux application which can be
    tweaked to do almost anything, but is tricky to setup. So, why
    would you use LIRC?
    <ul>
      <li>
        You might have a remote which is supported by LIRC but not the kernel.
        </li>
      <li>
        If you have a remote which isn't supported at all, LIRC is probably
        your best bet to get it running. </li>
      <li>
        You might be on a non-Linux platform supporting lirc e. g., MacOS.
        </li>
      <li>
        You might have an application which is more or less designed to use
        LIRC. </li>
      <li>
        You might need LIRC's capabilities e. g., modes where a single
        remote button can be teached to deliver different keys to the
        application. </a>
      <li>
        You might want to send IR signals to other devices (IR blasting).
        </li>
      <li>
        You might need LIRC's way of delivering application-specific events
        for remote buttons - handling several applications with one remote
        is easier with LIRC. </li>
      <li>
        You might need LIRC's way of delivering the events to several
        applications instead of just one. E. g., you can use irexec(1)
        to run arbitrary commands in parallel with an application such as
        mythtv or xbmc.</li>
    </ul>
    <p>
    So, while the kernel built-in handling works out of the box in many
    cases, there are still scenarios when LIRC is the right tool.
    </p>

    <A NAME="overall-configuration-decisions"></A><HR>
    <h2 align="center">Overall Configuration Decisions.</h2>
    <pre>
       ----------         ---------------------               ----------
       |        |         |                   |               |        |
       |        |---->----| Linux input layer |------->-------| Appli- |
       |        |         |                   |  /dev/input   | cation |
       |        |         ---------------------               |        |
--->---| kernel |                |        |                   ----------
remote |        |       devinput v        |
       |        |                |        ^ uinput
       |        |                |        |                   ----------
       |        |         ---------------------               | Appli- |
       |        |---->----|      lirc         |------->-------| cation |--
       |        |         |                   | /var/run/lirc |        | |
       ----------         ---------------------               ---------- |--
                                                                |        | |
                                                                ---------- |
                                                                  |        |
                                                                  ----------
    </pre>
    <p>
    LIRC can be run together with the kernel in different ways. You need
    to decide on a general approach first.
    </p>
    <p>
    Depending on whether lirc is used or not application will get data
    either from the input layer (/dev/input) or from LIRC (/var/run/lirc).
    Using the LIRC data requires application support. Support for LIRC
    is common in typical linux htpc applications like mythtv, xbmc and vlc.
    </p>
    <p>
    The /var/run/lirc interfaces allows several applications to receive
    input events. On the other hand, the /dev/input interfaces only allows
    one  application to receive the events.
    </p>
    <ul><li>
    A common scenario is to not involve lirc at all, the upmost
    path in the picture (kernel -&gt Linux input layer -&gt application).
    Unless there is reason to use lirc <a href="#why-use-lirc">(above)</a>)
    this is probably the way to go.
    </ul></li>
    <p>
    If you need to use lirc, there is two cases depending on if your
    remote is supported by the kernel or not.
    </p>
    <ul>
    <li>
    If it's supported, you should probably at least first try using the
    linux input layer decoding and use that as input to lirc. This is the
    devinput data path in picture (kernel -&gt Linux input layer -&gt lirc
    -&gt app).
    </li>
    <li>
    If the kernel built-in decoding can't be used you need to use a lirc
    driver instead. This is the bottom data path (kernel -&gtlirc -&gt app).
    </li>
    </ul>
    <p>
    Last option is to connect the LIRC driver to the linux input layer
    using LIRC's --uinput option. This means that application sees the
    input as coming from the kernel, and LIRC's other capabilities are
    not available. This is not described here.
    </p>
    <A NAME="basic-setup-flow"></A><HR>
    <h2 align="center">Basic setup flow</h2>
    <pre>
      ------------                   Often needs a device e. g.,
      |  driver  |                   /dev/input/eventXX
      ------------
           |
           v  IR pulse data          Use mode2(1) to debug.
           |
   ----------------
   |  lirc pass 1 |                  lircd.conf config file.
   ----------------
           |
           v  Key symbols            Use irw(1) to debug.
           |
   ----------------
   |  lirc pass 2 |                  lircrc config file.
   ----------------
           |
           v  Application strings    Use ircat(1) to debug.
           |

      Applications
    </pre>

    The overall lirc blues:
    <ul>
       <li> The IR signal is caught by the linux kernel drivers, and
            the data from the kernel is then caught by LIRC using a
            lirc driver. The lirc driver often needs to know from
            which device it should get the kernel data. This is
            described in
            <A HREF="#determine-driver-and-device">Determine driver and
             device</a>.</li>
       <li> In the next step, lirc converts the IR pulse data from the
            lirc  driver to key symbols either using
            <A HREF="#key-symbols-using-linux-input-layer">the linux input
            layer</a> or <A HREF="#key-symbols-using-lirc-drivers">an lirc
            driver</a> using the lircd.conf file.</li>
       <li> In the next step the application converts the key symbols
            to application-specific strings using the ~/.lircrc file. This
            is described in
            <A HREF="#converting-key-symbols-to-application-strings">
             Convert the key symbols to application strings</a> .</li>
    </ul>
    <A NAME="determine-driver-and-device"></A><HR>
    <h3 align="center">Determine driver and device</h3>
    <p>
    To determine the driver to use you might need to know the name of your
    device, what module the kernel has loaded for it and the device
    it's connected to.</p>
    <p>
    The first thing to do is to invoke ir-keytable:
    <pre>
    $ ir-keytable
    Found /sys/class/rc/rc0/ (/dev/input/event11) with:
        Driver em28xx, table rc-pinnacle-pctv-hd
        Supported protocols: NEC RC-5 RC-6
        Enabled protocols: RC-5
        Extra capabilities: <access denied>
    </pre> </li>
    If you get this kind of output you know the event device
    (/dev/input/event11) and the kernel module loaded (em28xx).
    Furthermore, since ir-keytable finds the device you know that the
    driver is part of the rc subsystem.  Not all devices are recognized
    by ir-keytable, though.</p>
    <p>
    Next step is inspect dmesg, possibly after reconnecting your device.
    If you have a standard IR remote which is recognized by the kernel
    you can find how it's registered as rc0:
    <pre>
     usb 3-2: Product: eHome Infrared Transceiver
     Registered IR keymap rc-rc6-mce
     input: Media Center Ed. eHome Infrared Remote Transceiver (0609:031d)
          as /devices/pci0000:00/0000:00:14.0/usb3/3-2/3-2:1.0/rc/rc0/input16
     rc0: Media Center Ed. eHome Infrared Remote Transceiver (0609:031d)
          as /devices/pci0000:00/0000:00:14.0/usb3/3-2/3-2:1.0/rc/rc0
     input: MCE IR Keyboard/Mouse (mceusb) as /devices/virtual/input/input17
     rc rc0: lirc_dev: driver ir-lirc-codec (mceusb) registered at minor = 0
   </pre>
    </p>
    If you find something like this you have a device which isn't an ir
    device, with a 'X10' in the name (in this case an RF remote)
    <pre>
        usb 2-2: Product: RF receiver
        usb 2-2: Manufacturer: X10 WTI
    </pre>
    Even if you have an ir device, you might see something like this if the
    kernel sees it as a keyboard rather than a remote. Here, an usb
    keyboard from JITTEL:
    <pre>
    Product: JTTEL Composite Devices
    hid-generic 0003:20E8:5820.0001: input,hidraw0: USB HID v10.01 Keyboard
        [JTTEL Inc. JTTEL Composite Devices] on usb-0000:00:1d.1-1/input0
    </pre>
    </p>
    <p>
    For devices like these which not are registered as rc devices (and thus
    not recognized by ir-keytable) you need to find out the corresponding
    event device as described in <a href="#appendix-2">Appendix 2</a> .</p>
    <p>
    Knowing the device name, the kernel module loaded (if any) and perhaps also
    a /dev/input device you have to select a driver:
    <ul>
       <li>
         If ir-keytable located the device you can use the devinput driver.
         This means that the kernel decodes the ir signals and converts them
         to button press symbols. Use something like (with device as from
         ir-keytable):
         <pre>
                --driver devinput --device /dev/input/event11
         </pre></li>
       <li>
         If you dont wan't to use the decoding done by the kernel, but the
         device is recognized by ir-keytable you can have lirc decode the
         raw signal from the driver. This means using the default driver
         which is accesses the kernel on a /dev/lirc device, normally
         /dev/lirc0.  Use something like:
         <pre>
               --driver default --device /dev/lirc0
         </pre></li>
       <li>
         if you can find the device name and/or the module in the
         <a href="http://www.lirc.org/html/table.html">driver list </a>
         you might try to use this driver.  Refer to <a href="#appendix-3">
         Appendix 3</a> for details.</li>
       <li>
         If you have a device such as a keyboard which is not recognized
         and can't find a driver in the driver list, your only option is
         using the devinput driver (above).</li>
     </ul>
     If you are to use the devinput driver, read on. Otherwise proceed to
     <A HREF="#key-symbols-using-lirc-drivers">Getting the key symbols using
     lirc driver</A>


    <A NAME="key-symbols-using-linux-input-layer"></A>
    <A NAME="getting-the-key-symbols-using-linux-input-layer"></A><HR>
    <h3 align="center">Getting the key symbols using linux input layer</h3>
    <pre>
  -----------------
  |    kernel     |
  -----------------
        |
        v
        |
  -----------------
  |  input layer  |
  -----------------
        |
        v  /dev/input/eventX         Use ir-keytable to manage and debug
        |
  ----------------
  |    lirc      |                   Use devinput driver
  |              |                   Use lircd.conf.devinput
  ----------------
        |
        v  key symbols               Use irw to debug
        |

    </pre>
    <p>
    If you're lucky, your remote is already supported by the kernel. In
    order to find out, the first task is to locate the event device,
    something like /dev/input/event12 which is connected to your IR
    device. This is described in <a href="#appendix-2">appendix 2</a>.
    </p>
    <p>
    With the device known use ir-keytable to test if your remote works:
    <pre>
    # ir-keytable -t -d /dev/input/event13
    </pre>
    Press buttons on the remote. If it starts to print out scan codes
    and key symbols everything is fine. Otherwise, try to change the
    protocol (see the ir-keytable manpage). If this doesn't work, it
    might be the end of the road and you might need to use the lirc
    driver option instead.  </p>
    <p>
    Check that all buttons generate output when testing. If there are
    buttons which are not mapped (no key symbol) you might not be
    able to fix this unless you go for the lirc driver option (to change
    the key symbol is perfectly possible, but probably not what you want
    here).  </p>
    <p>
    Then, grab the devinput/lircd.conf.devinput file
    <a href="http://sourceforge.net/p/lirc/git/ci/master/tree/remotes/">
    (remotes) </a> and copy it to /etc/lirc/lircd.conf. Start the lircd
    daemon and use irw to check:
    <pre>
    $ lircd --device /dev/input/event13 --driver devinput
    $ irw
    </pre>
    Press remote buttons. You should see the key symbols being printed.
    When so you are done and can proceed to
    <A HREF="#key-symbols-to-app-strings">Convert key symbols to application
    strings</a> </p>
    <p>
    Depending on your box, it might be that the event device found this
    way changes after a reboot. If this becomes o problem, look into
    <a href="#appendix-2">appendix 6</a>

    <A NAME="key-symbols-using-lirc-drivers"></A><HR>
    <h3 align="center">Getting the key symbols using lirc drivers</h3>
    <pre>
  ---------------------------------
  |    kernel devices             |
  ---------------------------------
       |       | kernel rc driver |  Needs configuration
       |       -- -----------------
       |                  |
       v                  v          raw pulse data
       |                  |
  ---------------         |
  | LIRC driver |----------
  ---------------
       |
       v      pulses                 Use mode2 to debug.
       |
  ---------------
  | LIRC pass 1 |                    lircd.conf
  ---------------
       |
       v      keysyms                Use irw to debug
    </pre>
    <p>
      You have already determined the driver and perhaps device to use.
      Make sure the lirc driver can read the remote, and produce pulses:
    </p>
    <ul>
      <li>
      Choose a method to configure the kernel built-in handling,
      implement it and verify that it works <a href="#appendix-1">
      (Appendix 1)</a>. As a last step, fire-up your application
      and make sure the remote does not affect it in any way.</li>
      <li> Check using mode2(1), verify that you get pulses using
           the --raw option. </li>
      <li>
      Update the configuration file which is used by lircd to use
      the driver and device (/etc/sysconfig/lirc or
      /etc/lirc/hardware.conf on many systems) </li>
    </ul>
    <p>
       lirc pass 1: Using lircd.conf, convert pulses to key symbols
       like KEY_UP:
    </p>
    <ul>
      <li>
        Read the <a href="configure.html#lircd.conf">lircd.conf </a>
        chapter. Either use a pre-existing lircd.conf
        <a href="http://sourceforge.net/p/lirc/git/ci/master/tree/remotes/">
        (remotes)</a> or roll your own using <a href="irrecord.html">
        irrecord(1)</a>.</li>
      <li>
        If using a predefined lircd.conf, ensure it uses proper key symbols
        <a href="#appendix-5">(below)</a>. </li>
      <li>
        Install the lircd.conf and start lircd daemon using something like:
        <pre>
        $ lircd --driver default --device /dev/lirc0
        </pre>
        Verify the results using irw(1). Check all buttons! </li>
    </ul>
    <A NAME="key-symbols-to-app-strings"></A>
    <A NAME="converting-key-symbols-to-application-strings"></A><HR>
    <h3 align="center">Converting key symbols to application strings</h3>
    <pre>
       |
       v      keysyms                Use irw to debug.
       |
  ---------------
  | LIRC pass 2 |                     ~/.lircrc
  ---------------
       |
       |      /var/run/lirc/lircX
       v      config strings
       |                             Use ircat to debug.
       |
  ---------------
  | Application |
  ---------------
</pre>
    <p> By now you should know the driver and device used when running
       lircd. Update the configuration files used to control the service
       with these (e. g., /etc/sysconfig/lirc or /etc/lirc/hardware.conf).
       </p>
    <ul><li>
      Check that you can start/stop a working service, irw is your friend.
    </li></ul>
    <p>Using ~/.lircrc, convert the key symbols to application-specific
      strings:
      <ul>
        <li> Read the <a href="configure.html#lircrc_format">.lircrc chapter
          </a> and create your ~/.lircrc. generate-lircrc.sh can generate
            a starting point <a href="appendix-5">(below)</a>.</li>
        <li>Restart the lircd daemon. Use <a href="ircat.html">ircat(1)</a>
            to verify your application settings i. e., what your
            application actually recieves when pushing the remote button.</li>
      </ul>
    </p>
    <p>Test the application, and investigate further steps:</p>
    <ul>
      <li> Configure your application to use the same socket as irw and
        test it.</li>
      <li>Once the application is up, you might want to exploit LIRC's
        capabilities: </li>
      <ul>
         <li>Using <a href="irexec.html">irexec(1)</a> you can configure
           lirc to run arbitrary program when a button is pressed.</li>
         <li> Using <a href="lircmd.html">lircmd(1)</a> you can use lirc
           to let the remote emulate a mouse. </li>
         <li>You can setup lirc to transmit IR signals (IR blasting) to
           other devices e. g., let the remote send ir signals to a TV
           set. The program is <a href="irsend.html">irsend(1)</a>, you
           might want to scan the web for howto:s.</li>
       </ul>
    </ul>
    <A NAME="appendixes"></A><HR>
    <h2 align="center"> Appendixes</h2>

    <A NAME="appendix-1"></A>
    <h3 align="center"> A1: Configuring the kernel</h3>
     <p>
     When using an LIRC ir driver, the kernel ir driver must be
     configured to send the data only to the /dev/lirc device and not
     to the general input layer. If not, each button event will delivered
     twice to the application, both through /var/run/lirc and /dev/input.
     </p>
     <p>
     Also, some lirc drivers conflicts with the kernel drivers. A common
     example is the lirc atilibusb driver which conflicts with the kernel
     ati_remote driver. Another example is lirc serial drivers which
     conflicts with the kernel default tty driver. Such conflicts shows
     up as dmesg output about not being able to open the involved device,
     plus various other symptoms.
     </p>
     <p>
     The kernel driver configuration can be done using the interfaces under
     /sys/class/rc or using a udev rule. Conflicting kernel drivers must
     be blacklisted. Conflicts on serial ports can be handled by disabling
     the kernel serial driver for that port.</p>
    <A NAME="kernel-driver-configuration"></A>
    <h4 align="center"> Kernel driver configuration.</h4>
    <p>
    The builtin ir driver subsystem is aware of LIRC, and is capable to send
    all data through /dev/lirc0. To configure:
    <pre>
        # echo -- 'lirc' > /sys/class/rc/rc0/protocols
    </pre>
    Here, 'rc0' is OK if you have only one infrared device. Note that
    this is not persistent, you need to do this after each boot.  </p>
    <p>
    Using '-lirc' instead restores the normal kernel operation when
    stopping LIRC. </>
    <A NAME="udev-rules"></A>
    <h4 align="center">Udev rules</h4>
    <p>Instead of issuing commands, you can create a file
      /etc/udev/rules.d/99-remote-control-lirc like:
    <pre>
       SUBSYSTEM=="rc", ATTR{protocols}="lirc"
    </pre>
    This is persistent and makes all ir devices send data only
    through /dev/lirc where it can be retrieved by the 'default' driver.</p>
    <A NAME="blacklisting-modules"></A>
    <h4 align="center">Blacklisting modules.</h4>
    <p>
    When using remotes which are not infrared, the corresponding driver is
    not affected by the methods above. One example is an RF remote I have
    which uses the atilibusb LIRC driver. This conflicts with the ati_remote
    kernel module, which thus needs to be disabled. Do this by creating the
    file /etc/modprobe.d/blacklist-atiremote.conf like:
    <pre>
        # Conflicts with LIRC.
        blacklist ati_remote
    </pre>
    Finding out what module to blacklist is not always easy. dmesg(1)
    sometimes gives a hint about conflicts on a device. Another method is
    to boot the system without the usb device connected, and do a lsmod.
    After that, connect the device and make a new lsmod. Comparing the
    different outputs might give a clue.
    </p>
    <A NAME="serial_port_reservation"></A>
    <h4 align="center">Disabling kernel serial port reservation</h4>
    <p>
      Usually the default kernel serial port driver grabs all ports it
      auto-detects as soon as it is loaded and the LIRC modules won't
      be able to use any of them.  </p>
    <P>
      There are two solutions for this problem. Either you load the
      LIRC module before the kernel serial port driver is loaded
      or you call <em>setserial /dev/ttySx uart none</em> to release
      the according port. setserial usually is already called during
      boot-up in some init script whose location depends on the
      distribution you use. You should check your setserial
      configuration to only configure available ports. Debian users
      should adjust their <em>/etc/serial.conf</em>.
    </P>

    <A NAME="appendix-2"></A>
    <h3 align="center"> A2: Finding the event device</h3>
    <p>
    For many tasks it's necessary to find out the event device, something
    like /dev/input/event12, which is connected to your IR input.</p>
    <p>
    The first try is to invoke ir-keytable without any options:
    <pre>
        $ ir-keytable
        Found /sys/class/rc/rc0/ (/dev/input/event11) with:
            Driver em28xx, table rc-pinnacle-pctv-hd
            Supported protocols: NEC RC-5 RC-6
            Enabled protocols: RC-5
            Extra capabilities: <access denied>
    </pre>
    </p>
    <p>
    If the reported device matches your expectations you're done - here we
    have /dev/input/event11.</p>
    <p>
    If this doesn't work next try is to look in in /dev/input/by-id. If you
    find a device here which looks like your device, check where it's linked:
    <pre>
    $ ls /dev/input/by-id
    usb-Plus_More_Enterprise_LTD._USB-compliant_keyboard-event-kbd
    usb-_Home_Infrared_Transceiver_TS0013Yn-event-if00

    $ ls -l /dev/input/by-id/usb-eHome_Infrared_Transceiver_TS0013Yn-event-if00
    lrwxrwxrwx [cut] /dev/input/by-id/usb-eHome_Infrared_Transceiver_TS0013Yn-event-if00 -> ../event13
    </pre>
    So, here your interface is /dev/input/event13, and your're done.</p>
    <p>
    If this does not work, cat the input devices under /sys.
    <pre>
        $ cat /proc/bus/input/devices > foo
    </pre>
    Look in foo to find this snippet about your device:
    <pre>
        I: Bus=0003 Vendor=2013 Product=024f Version=0001
        N: Name="em28xx IR (em28174 #0)"
        P: Phys=usb-0000:00:1d.7-1/input0
        S: Sysfs=/devices/pci0000:00/0000:00:1d.7/usb1/1-1/rc/rc0/input14
    </pre>
    Here, the device is /dev/input/event14. </p>

    <A NAME="appendix-3"></A>
    <h3 align="center"> A3: Understanding the driver table</h3>
    <p>
    The <a href="http://www.lirc.org/html/table.html">driver list </a>
    gives some hints on the usage for each driver. The important columns
    are "Hardware", "Required LIRC kernel module", "lircd driver" and
    "Default lircd and lircmd config files".</p>
    <p>
    The "Hardware" column should be obvious. Note that it in many cases
    it refers to the receiver unit (e. g., the name reported by dmesg), not
    the name of the remote. So, before looking for a suitable driver
    use dmesg to find out the name as described in <a href="apppendix-2">
    Appendix 2</a></p>
    <p>
    The "lircd driver" refers to the argument you should give to lircd
    i. e., --driver=... You might need to check that the driver is
    available using <em>irrecord -H help</em>. If it's not listed here
    you need to rebuild lirc which is outside the scope of this document.
    </p>
    <p>
    The "Required LIRC kernel modules" refers to modules that are part of
    the linux kernel. Some of these are regular modules and should be
    available in any reasonably updated linux system. However, some of
    these modules are part of the staging drivers and might not be
    available on your system.</p>
    <p>
    To look for a particular module just search for it in /lib/modules
    e. g.,
    <pre>
        $ find  /lib/modules/$(uname -r) -name lirc_imon\*
        /lib/modules/3.12.7-300.fc20.i686/kernel/drivers/staging/media/lirc/lirc_imon.ko
    </pre>
    If it's listed, kernel should load it automatically on-demand. If it's
    not you have to build the staging drivers, also outside the scope of
    this document.  </p>
    <p>
    Unfortunately, the driver list does not provide information on the
    device which should be used for a particular driver. The only way
    to be sure is actually inspecting he sources. You might try to search
    the web before walking this path, though.</p>

    <A NAME="appendix-4"></A>
    <h3 align="center"> A4: Normalizing the lircd.conf</h3>
    <p>
    Several of the pre-defined remotes uses non-standard key symbols. This
    is a Bad Thing, which makes it harder to create the ~/.lircrc file
    in next step. You should replace all non-standard definitions with
    official key symbols where it's possible. Some buttons might not be
    possible to map to standard symbols is a sane way, and could be left
    as-is. But the vast majority of buttons should use standard symbols.
    The standard symbols a. k. a. the namespace, is listed by irrecord -l.
    </p>
    <p>
    The script generate-lircrc is helpful here. List all non-standard
    symbols in lircd.conf:
    <pre>
        $ generate-lircrc.sh -s -c /etc/lirc/lircd.conf
    </pre>
    Update the lircd.conf file with standard key symbols as applicable:
    <pre>
        $ sudo generate-lircrc.sh -u -c /etc/lirc/lircd.conf
    </pre>
    </p>

    <A NAME="appendix-5"></A>
    <h3 align="center"> A5: Generating the .lircrc</h3>
    <p>
    The .lircrc file basically combines the remote buttons with application
    capabilities. To actually write a .lircrc file from scratch is not that
    hard, but it's a lot of work. generate-lircrc.sh can save some of this
    work by creating a starting point. For this to work , the lircd.conf
    file must be in place.</p>
    <p>
    The first step is to check if your application is supported by the script:
    <pre>
        $ ./generate-lircrc.sh -l
    </pre>
    if you find your application here, you can make an .lircrc for that app:
    <pre>
        $ ./generate-lircrc.sh -o . vlc
    </pre>
    If you're using the devinput lircd.conf, create a new version of that
    file which only contains the key symbols you are actually using. Use
    this instead in the -c option to let generate-lircrc.sh make it's work.
    </p>The generated file will look like (excerpt!)</p>
    <pre>

    # Created by /home/al/bin/generate-lircrc.sh at tis dec  3 23:26:18 CET 2013

    # See http://wiki.videolan.org/How_to_Use_Lirc

        begin
            prog   = vlc
            button = KEY_REWIND
            config = key-rewind
        end

        begin
            prog   = vlc
            button = KEY_FASTFORWARD
            config = key-faster
        end


        begin
            prog   = vlc
            button = KEY_NEXT
            config = key-next
        end

    # Unused buttons:
    #
    #    KEY_HOME
    #    KEY_GREEN
    #    KEY_RED
    #    KEY_YELLOW
    #
    # Unused capabilities:
    #
    #
    #    begin
    #        prog   = vlc
    #        button = KEY_EXIT
    #        config = key-quit
    #    end
    #
    #    begin
    #        prog   = vlc
    #        button = KEY_PLAY_PAUSE.
    #        config = key-play-pause
    #    end
    #
    #    begin
    #        prog   = vlc
    #        button = KEY_PLAY
    #        config = key-play
    #    end
    #
    </pre>
    <p>
    The comments are about buttons which havn't found a use, and capabilities
    in the program (vlc) which are not bound to a button. Obviously, this
    saves some work.</p>
    <p>
    The generate-lircrc.sh has a -h and a manpage option for more info.</p>
    <p>
    BEWARE: The configuration file generated this way is a starting point. It
    needs to be inspected and tweaked before it actually does it's job.

    <A NAME="appendix-6"></A>
    <h3 align="center">A6 : Addressing changing event devices</h3>
    <p>
    When using the devinput driver, input devices like /dev/input/event12
    might come up as another device after a reboot. If this becomes a problem,
    you should address the device using it's name or it's physical bus address.
    </p> <p>
    The first step is to inspect dmesg after connecting the device. There you
    should find something like:
    <pre>
    rc0: Media Center Ed. eHome Infrared Remote Transceiver (1784:0001) as
        /devices/pci0000:00/0000:00:12.0/usb4/4-4/4-4:1.0/rc/rc0
    </pre>
    Here you can see the device's name: "Media center Ed. eHome..." and it's
    address: ...usb4/4-4/4-4:1.0/rc/rc0.</p>
    <p>
    As long as you have only one remote of each kind you can use simple
    name matching like in
    <pre>
       --device=name='*eHome*'
    </pre>
    If you have several devices with the same name you need to use the address
    instead. Since this depends on how the device is connected, you lose if you
    disconnect the device and reconnect it to another socket. With this
    limitation you can use phys=*usb4/4-4/4-4:1.0* in the same way as name.

    <A NAME="appendix-7"></A>
    <h3 align="center">A7 : Running irexec</h3>
    <p>
    After having configured lirc, you might want to run irexec(1). Using
    this, you can bind remote buttons to any command you can run. It's
    typically used to shut down system, system volume controls etc.</p>
    <p>
    There is two ways to run irexec, both with their pros and cons.</p>
    <p>
    The first way is to run irexec as a system daemon. This can be done in
    many ways e. g., from a rc.local script or as a systemd service. Any way
    you will have security problems since running arbitrary commands and
    scripts as root is generally a bad idea. There is also the problem that
    irexec runs outside your session which means it's problematic to access
    the display, sound system and other resources typically bound to the
    session. On the other hand, this is flexible and since irexec runs as
    root it can in the end do anything </p>
    <p>
    The second way to run irexec is to run is as a part of the session. A
    standard way to do this is to drop a irexec.desktop file in the config
    autostart  directory, normally ~/.config/autostart.  Doing so you can
    use your desktop tools to control the service. Also, since the service
    runs as part of your session, it can access the display, sound system
    etc.</p>
    <p>
    The drawback is that since it runs as a regular user, it might run into
    permission problems e. g., when trying to shut down the computer. This
    can be handled using sudo, giving the user running irexec right to
    run specific commands otherwise requiring root permission. E. g., the
    following entry in /etc/sudoers  allows the htpc user to restart gdm,
    effectively making a soft reboot:
    <pre>
        ## Allows members of the htpc group to restart session service
        %htpc ALL=NOPASSWD: /usr/bin/systemctl restart gdm.service
    </pre>
    All in all, to configure irexec:
    <ul>
        <li> Copy irexec.desktop from the contrib directory to
             ~/.config/autostart</li>
        <li> Possibly add entries to /etc/sudoers (above) if you need to
             run otherwise restricted commands.</li>
        <li> Enable the session service using e. g. gnome settings or
             corresponding tools.</li>
        <li> Configure the ~/.lircrc file as described in
             <a href="configure.html#lircrc_format">.lircrc chapter </a>
             Note that you must specify "program = irexec" for irexec
             to pick up your configuration.</li>
    </ul>
  </BODY>
</HTML>
